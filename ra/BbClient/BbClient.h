#ifndef BbClient_H
#define BbClient_H

#include <string>
#include <stdio.h>
#include <limits.h>
#include <unistd.h>
#include <iostream>
#include <iomanip>

#include "sgx_urts.h"
#include <cassert>
#include "sgx_trts.h"
#include "sgx_tcrypto.h"
#include "sgx_uae_service.h"
#include "sgx_tseal.h"
#include <stdlib.h>
#include "sgx_utils.h"
#include "../../thc/App/th_definitions.h"

#include "LogBase.h"
#include "../GeneralSettings.h"
#include "Enclave.h"
#include "Messages.pb.h"
#include "VerificationReport.h"
#include "AttestationClient.h"

using namespace std;
using namespace util;

class BbClient {

public:
    BbClient(Enclave* pEnclave);
    virtual ~BbClient();
    
    bool Init();

    bool generatePkRequest(Messages::PkRequest& pkRequest);


    /***
    [Initialization-step 1: input pk, attestation quote Q']
    1. Verify that Q' is a valid Intel-signed quote that "pk was generated by [Secret-Key-Generation Enclave] running in secure mode"
    2. Generate an encryption key pair (bbpk, bbsk), output bbpk.
    3. Compute k=DH(bbsk, pk) the shared DH key of skg and bb
    4. Use the "independent attestation" mechanism to generate an Intel-signed quote that "bbpk was generated by [X-Black-Box Enclave] running in secure mode". This is Q, output.
    5. Seal (k) [sealing to MRENCLAVE] and the sealed data.
    ***/
    bool processPkResponse(Messages::PkResponse& pkResponse, 
                           Messages::GetSecretRequest& getSecretRequest);


    bool processGetSecretResponse(Messages::GetSecretResponse& getSecretResponse);

private:
    bool readCertificateFromMemory();
    bool obtainCertificate();


private:
    VerificationReport m_report;
    Enclave* m_pEnclave;
    AttestationClient* m_pClient;
    sgx_ec256_public_t* p_bb_pk = NULL;
    sgx_sealed_data_t* p_sealed_k = NULL;
};

#endif











